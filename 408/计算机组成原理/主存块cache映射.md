## 主存 与 cache
当我们讨论主存和缓存的映射方式时，通常指的是CPU缓存和主存之间的映射关系
我们编写程序的时候一般来说并不能直接选择**缓存映射策略**, 一般来说是cpu(现代计算机上IMC, Integrated Memory Controller)和内存控制器(较老的计算机设计在北桥, 北桥还负责连接CPU和显卡和io)实现的
但是我们可以通过调整局部数据访问模式, 来提高缓存命中率(还记得有个stackoverflow关于访问有个case, 顺序访问和随机访问差了几个数量级的速度吗?)

## 映射方式
1. 直接映射（Direct Mapped Cache）
主存中的块映射到cache中特定位置
- 优势
结构简单, 访问快
- 劣势
利用率低, 容易发生冲突缺失

2. 全相联映射（Fully Associative Cache）
可以加载到缓存中任意位置, 需要数据访问时需要check缓存中所有条目
- 优势
灵活, 缺失率低
- 劣势
硬件实现复杂, 成本高, 访问时间长

3. 组相联映射（Set Associative Cache）
折中, 缓存被划分为若干组, 每组若干块, 主存中的块可以映射到某一个组任意位置, 但不能映射到别的组
较好地平衡了速度和灵活性


### 缓存填充
cpu访问缓存中不存在的数据的时候, 整个块会从主存读取到缓存中, 这个过程称为缓存填充
现代计算机中, 缓存行(cache line)或内存块大小一般选择为64字节

### 块 Block
一般指缓存和主存之间传输数据的数据单元, 块的大小一般是2的幂次方字节

### 块内偏移 Block Offset
一个特定地址的数据在其所在存储块中的位置
用取模计算即可(其实可以直接用位运算来计算, 因为块大小一般都是2的幂)
假设块的大小为16字节（B = 16），我们想要访问地址为34的数据（A = 34）。
Block Offset = 34 mod 16 = 2
这意味着在块内，数据位于第2个位置（从0开始计数）。

## 为什么需要
1. 块内偏移地址（Block Offset）
作用：确定数据在缓存块内的具体位置。
计算：块内偏移地址是通过将主存地址与缓存块大小取模得到的。
2. 块号（Block/Set Index）
作用：确定数据应该存储在缓存的哪个块或组。
计算：块号是通过将主存地址除以缓存块大小，然后对缓存的总块数取模得到的。
3. 标记位（Tag）
作用：用于在缓存命中时验证存储在缓存中的数据是否是主存地址对应的数据。
计算：标记位是通过将主存地址除以（缓存块大小 * 缓存的总块数）得到的。

块内偏移地址：告诉我们数据在缓存块内的哪个字节。
块号：告诉我们数据应该在缓存的哪个位置。
标记位：确保我们访问的是正确的数据，因为不同的主存地址可能映射到缓存的同一位置。

### 标记阵列容量
缓存（cache）不仅存储了主存（main memory）中数据的副本，还需要存储额外的控制信息和状态信息，这就是所谓的“标记阵列”或“标记存储器”。这些信息是用来确定缓存中的数据是否有效，以及它对应的是主存中的哪一部分数据
1. 有效位（1位）
每个Cache行都需要一个有效位来标识这个Cache行是否包含有效的数据
总容量影响：Cache行数量 × 1位。
2. 标记位
3. 一致性维护位（脏位，1位）
在Write Back策略中，需要一个脏位来标识这个Cache行的数据是否被修改。
不是所有的写策略都需要脏位。例如，Write Through策略就不需要。
总容量影响（如果使用脏位）：Cache行数量 × 1位。
4. 替换算法控制位
用于实现Cache替换策略的控制位，例如LRU（最近最少使用）算法需要额外的位来记录使用情况。
需要的位数取决于具体的替换算法和Cache的大小。


### 策略
- write back
write back是一种写策略, 当修改了cache数据的时候, 不会立刻把修改后的数据写到主存, 而是标记这个Cache行为“脏”（dirty），表示其内容已经被修改，并且与主存中相应的数据不一致
通过延迟将修改后的数据写回到主存中，可以减少主存访问的次数

- write through
当处理器写入数据到Cache时，同时将数据写回到主存。这种策略保证了Cache和主存之间的数据一致性，但可能导致更高的主存访问开销

- write once
与Write Through类似，但是在数据第一次写入Cache时不写回主存，只有在数据被再次修改时才写回主存

- no write allocate
当写失效（写的数据不在Cache中）发生时，直接将数据写回到主存，而不是先将缺失的块装入到Cache再进行写操作

## 计算(2015年15题为例)
1. 直接映射
tag(标记位) 块号 块内偏移地址
- 块内偏移
假设主存每个块存储16个字节
计算记录块内偏移地址所需位数, 可以当作计算记录块内所有偏移所需位数, 也就是
[0, 0b1000)左闭右开(按字节编址)
所需4位
- 块号
计算块号首先要计算缓存的总块数
假设需求存放4k字的数据(1字==32位)
4 * 1024 * 4B = 16KB
16KB/16B = 1K(需要1000个块)
为了记录1000个块, 易得需要log2(1000-1)+1 = 10位
- tag
32-4-10 = 18位

write back方式有一致性维护位
cache总容量 = 
标记阵列容量(有效位(1位), 标记位(18位), 一致性维护位(脏位1位), 替换算法控制位(题目没说不考虑))
+
存储容量
= (18+1+1) * 1000 + 4k * 32 (这里的4k * 32也可以用16B(*8) * 1000来算, 一样的)
= 20k + 4k*32 = 148k
阵列容量中的这32位是存储在缓存（cache）中的

### 关于14位究竟去哪里了为什么不存储
这14位并不是存储在某个特定的硬件位置中，它们是从主存地址中提取出来的。主存地址通常是一个较长的二进制数字，通过硬件电路，可以从这个地址中提取出块内偏移和块号等信息。
具体来说：
- 当CPU发出一个内存访问请求时，它会提供一个内存地址。
- 这个地址会被分解成几个部分，其中包括块内偏移和块号。
- 块号会被用来在缓存中查找对应的缓存行。
- 一旦找到缓存行（或者从主存中加载数据到缓存行），块内偏移会被用来从缓存行中找到具体的数据字节。

所以这14位实际上是从CPU提供的内存地址中解析出来的，而不是存储在某个具体的位置。
块内偏移和块号是通过地址直接计算得到的，不需要存储在标记阵列中

### 关于为什么18位就足够验证是否正确
首先，要明确一点：在直接映射缓存中，给定的块号确定了缓存中的一行。这就是说，主存中的多个块可能会映射到同一个缓存行，从而导致缓存替换。这种映射机制确保了我们可以快速找到一个块在缓存中的位置，但代价是可能发生冲突。

考虑到这种映射机制，我们可以明白为什么用18位标记足够了：因为在32位主存地址中，10位已经用于块号，这10位决定了一个块在缓存中的位置。我们只需要额外的18位来区分那些映射到同一缓存行的不同块。

当CPU想要从一个特定的32位主存地址中读取数据时：

它会用10位块号来查找缓存中的位置。
然后，它会检查该缓存行的18位标记是否与主存地址中的18位标记匹配。如果匹配，说明缓存中的数据是正确的；如果不匹配，说明缓存行中的数据是其他块的数据，CPU需要从主存中重新加载数据。
这种机制确保了，尽管多个块可能映射到同一个缓存行，但我们可以通过标记位准确地确定缓存中的数据是否是我们需要的。